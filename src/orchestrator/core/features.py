"""Features.json manager for structured feature tracking.

This module implements the JSON-based feature list pattern from Anthropic's
long-running agent research. Features are stored with passes:boolean fields
that actors can only toggle (not edit or remove).
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from typing import List, Optional


@dataclass
class Feature:
    """A single feature requirement with pass/fail status."""

    id: str
    category: str  # "core", "nice_to_have", "infrastructure"
    description: str
    verification_steps: List[str] = field(default_factory=list)
    passes: bool = False
    last_verified: Optional[str] = None
    verified_by_task: Optional[str] = None

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict) -> "Feature":
        """Create Feature from dictionary."""
        return cls(
            id=data["id"],
            category=data.get("category", "core"),
            description=data["description"],
            verification_steps=data.get("verification_steps", []),
            passes=data.get("passes", False),
            last_verified=data.get("last_verified"),
            verified_by_task=data.get("verified_by_task"),
        )


class FeaturesManager:
    """Manages features.json for structured feature tracking."""

    def __init__(self, workspace: Path) -> None:
        self.workspace = Path(workspace).resolve()
        self.features_path = self.workspace / "current" / "features.json"
        self._features: List[Feature] = []

        if self.features_path.exists():
            self._load()

    def _load(self) -> None:
        """Load features from features.json."""
        try:
            content = self.features_path.read_text()
            data = json.loads(content)
            self._features = [Feature.from_dict(f) for f in data.get("features", [])]
        except (json.JSONDecodeError, KeyError):
            self._features = []

    def save(self) -> None:
        """Save features to features.json."""
        self.features_path.parent.mkdir(parents=True, exist_ok=True)

        data = {
            "version": "1.0",
            "generated": datetime.now().isoformat(),
            "warning": "DO NOT EDIT THIS FILE DIRECTLY. Feature status is updated automatically by the orchestrator.",
            "features": [f.to_dict() for f in self._features],
        }

        self.features_path.write_text(json.dumps(data, indent=2))

    def initialize_from_goals(self, goals: List[dict]) -> None:
        """Create features.json from GOALS.md content if it doesn't exist."""
        if self.features_path.exists() and self._features:
            return  # Already initialized

        feature_id = 1
        for goal in goals:
            feature = Feature(
                id=f"feature-{feature_id:03d}",
                category=goal.get("tier", "core"),
                description=goal.get("description", ""),
                verification_steps=[
                    goal.get("measurable", "Manual verification required")
                ],
                passes=goal.get("achieved", False),
            )
            self._features.append(feature)
            feature_id += 1

        self.save()

    def add_feature(
        self,
        description: str,
        category: str = "core",
        verification_steps: Optional[List[str]] = None,
    ) -> Feature:
        """Add a new feature to track."""
        existing_ids = [
            int(f.id.split("-")[1])
            for f in self._features
            if f.id.startswith("feature-")
        ]
        next_id = (max(existing_ids) if existing_ids else 0) + 1

        feature = Feature(
            id=f"feature-{next_id:03d}",
            category=category,
            description=description,
            verification_steps=verification_steps or [],
            passes=False,
        )
        self._features.append(feature)
        self.save()
        return feature

    def mark_passing(self, feature_id: str, task_id: str) -> bool:
        """Mark a feature as passing. Returns True if found and updated."""
        for feature in self._features:
            if feature.id == feature_id:
                feature.passes = True
                feature.last_verified = datetime.now().isoformat()
                feature.verified_by_task = task_id
                self.save()
                return True
        return False

    def mark_failing(self, feature_id: str) -> bool:
        """Mark a feature as failing. Returns True if found and updated."""
        for feature in self._features:
            if feature.id == feature_id:
                feature.passes = False
                feature.last_verified = datetime.now().isoformat()
                feature.verified_by_task = None
                self.save()
                return True
        return False

    def get_failing_features(self) -> List[Feature]:
        """Get all features that are not passing."""
        return [f for f in self._features if not f.passes]

    def get_passing_features(self) -> List[Feature]:
        """Get all features that are passing."""
        return [f for f in self._features if f.passes]

    def get_feature(self, feature_id: str) -> Optional[Feature]:
        """Get a feature by ID."""
        for feature in self._features:
            if feature.id == feature_id:
                return feature
        return None

    def get_progress_summary(self) -> str:
        """Get a summary of feature progress."""
        total = len(self._features)
        passing = len(self.get_passing_features())

        if total == 0:
            return "No features defined"

        percentage = (passing / total) * 100
        return f"{passing}/{total} features passing ({percentage:.0f}%)"

    def get_features_for_prompt(self, include_passing: bool = False) -> str:
        """Get features formatted for inclusion in actor prompts."""
        lines = [
            "## Feature Requirements",
            "",
            "⚠️ **IT IS UNACCEPTABLE TO EDIT, REMOVE, OR MODIFY THESE FEATURES.**",
            "You may only implement functionality that causes them to pass.",
            "",
        ]

        failing = self.get_failing_features()
        if failing:
            lines.append("### Failing Features (NEED IMPLEMENTATION)")
            for f in failing:
                lines.append(f"- [ ] {f.id}: {f.description}")
                if f.verification_steps:
                    for step in f.verification_steps[:2]:
                        lines.append(f"    - Verify: {step}")
            lines.append("")

        if include_passing:
            passing = self.get_passing_features()
            if passing:
                lines.append("### Passing Features (DO NOT BREAK)")
                for f in passing:
                    lines.append(f"- [x] {f.id}: {f.description}")
                lines.append("")

        lines.append(f"**Progress**: {self.get_progress_summary()}")
        return "\n".join(lines)

    @property
    def features(self) -> List[Feature]:
        """Get all features."""
        return list(self._features)


def sync_features_with_goals(features_manager: FeaturesManager, goals_manager) -> None:
    """Sync features.json with GOALS.md, creating features for new goals."""
    existing_descriptions = {f.description.lower() for f in features_manager.features}

    for goal in goals_manager.core_goals:
        if goal.description.lower() not in existing_descriptions:
            features_manager.add_feature(
                description=goal.description,
                category="core",
                verification_steps=[goal.measurable_criteria]
                if goal.measurable_criteria
                else [],
            )
